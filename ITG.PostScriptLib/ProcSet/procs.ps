%!PS-Adobe-3.0
%%Creator: Sergey S. Betke <sergey.s.betke@yandex.ru>
%%Copyright: 2018 Sergey S. Betke <sergey.s.betke@yandex.ru>
%%+ See LICENSE at https://github.com/Metrolog/marks
%%DocumentData: Clean7Bit
%%DocumentNeededResources: ProcSet (arrays) 2.2 0
%%DocumentSuppliedResources: ProcSet (procs)
%%Version: 2.3 0
%%EndComments
%%BeginProlog

%%IncludeResource: ProcSet arrays 2.2 0

%(procs) /ProcSet resourcestatus { pop pop } {
%!PS-Adobe-3.0 Resource-ProcSet
%%BeginResource: ProcSet (procs)
/procs <<

/switch
{
  exch  2 copy  known
    { get exec }
    {
        exch
        dup /default known
        {
          exch pop
          /default get exec
        }
        {
          pop
          $error begin
            /errorinfo exch def
            /errorname /unexpectedswitchvalue def
            /command /switch def
            /recordstacks false def
          end
          stop
        }
      ifelse
    }
  ifelse
} bind

/define_args
{
  /arrays /ProcSet findresource /areverse get exec

  dup [ exch
      {
        dup type
        <<
          /nametype {} bind
          /dicttype {
              dup /arg known
              { /arg get }
              {
                $error begin
                  /errorinfo exch def
                  /errorname /unexpectedparamdefinition def
                  /command /define_args def
                  /recordstacks false def
                end
                cleartomark
                pop
                stop
              }
            ifelse
          } bind
          /default {
            $error begin
              /errorinfo exch def
              /errorname /unexpectedparamdefinition def
              /command /define_args def
              /recordstacks false def
            end
            cleartomark
            pop
            stop
          } bind
        >>
        /procs /ProcSet findresource /switch get exec
      }
    forall
  ]

  exch
  <<  exch
      {
        dup type
        <<
          /nametype { << >> } bind
          /dicttype {
            dup  /arg get  exch
            begin
              currentdict /arg undef
              currentdict
            end
          } bind
        >>
        /procs /ProcSet findresource /switch get exec
      }
    forall
  >>  begin

      1 index  type  /dicttype  eq
      { pop }
      {
        dup length dict begin
          { exch def } forall
          currentdict
        end
      }
    ifelse

      {
          currentdict  2 index  known
          {
              {
                  currentdict  2 index  get  dup length dict  copy  begin
                    [
                        [ /type ]
                        {
                            dup currentdict exch known
                            { dup currentdict exch undef }
                            { pop }
                          ifelse
                        }
                      forall
                      currentdict { pop } forall
                    ]
                  end
                  {
                    dup  currentdict  4 index  get  exch get
                    /procs /ProcSet findresource  /params_attributes get
                      dup  3 index  known
                      {
                        3 -1 roll
                        $error begin
                          dup [ exch ] /errorinfo exch def
                          /errorname /invalidparamattributevalue def
                          /command /define_args def
                          /recordstacks false def
                        end
                        get
                        exec
                      }
                      {
                        pop
                        pop
                        $error begin
                          2 index  exch  2 array  astore  /errorinfo exch def
                          /errorname /unknownparamattribute def
                          /command /define_args def
                          /recordstacks false def
                        end
                        stop
                      }
                    ifelse
                  }
                forall

              } stopped
              {
                pop pop
                end
                stop
              }
            if

            def
          }
          {
            $error begin
              2 array  astore  /errorinfo exch def
              /errorname /unknownparam def
              /command /define_args def
              /recordstacks false def
            end
            end
            stop
          }
        ifelse
      }
    forall

    currentdict

  end
  readonly
  1 dict begin
  /args exch def
} bind

/leave_local_scope
{
  end
} bind

/params_attributes <<

/type % param_name param_value type_name --> param_name param_value
{
  <<
    /arraytype {
      dup type
          dup /arraytype eq
          /packedarraytype eq
        or not
        { 1 array  astore }
      if
    } bind
    /booleantype {
        dup type  /booleantype  eq  not
        {
          $error begin
            dup /errorinfo exch def
            /errorname /typecheck def
            /command /define_args def
            /recordstacks false def
          end
          stop
        }
      if
    } bind
    /dicttype {
        dup type  /dicttype  eq  not
        {
          $error begin
            dup /errorinfo exch def
            /errorname /typecheck def
            /command /define_args def
            /recordstacks false def
          end
          stop
        }
      if
    } bind
    /filetype {
        dup type  /filetype  eq  not
        {
          $error begin
            dup /errorinfo exch def
            /errorname /typecheck def
            /command /define_args def
            /recordstacks false def
          end
          stop
        }
      if
    } bind
    /fonttype {
        dup type  /fonttype  eq  not
        {
          $error begin
            dup /errorinfo exch def
            /errorname /typecheck def
            /command /define_args def
            /recordstacks false def
          end
          stop
        }
      if
    } bind
    /gstatetype {
        dup type  /gstatetype  eq  not
        {
          $error begin
            dup /errorinfo exch def
            /errorname /typecheck def
            /command /define_args def
            /recordstacks false def
          end
          stop
        }
      if
    } bind
    /integertype {
      cvi
    } bind
    /marktype { } bind
    /nametype {
      dup type
      <<
        /stringtype { cvn } bind
        /nametype { } bind
        /default {
          $error begin
            2 copy  2 array  astore  /errorinfo exch def
            /errorname /typecheck def
            /command /define_args def
            /recordstacks false def
          end
          stop
        } bind
      >>
      /procs /ProcSet findresource /switch get exec
    } bind
    /nulltype { } bind
    /operatortype {
        dup type  /operatortype  eq  not
        {
          $error begin
            dup /errorinfo exch def
            /errorname /typecheck def
            /command /define_args def
            /recordstacks false def
          end
          stop
        }
      if
    } bind
    /packedarraytype {
      dup type
          dup /arraytype eq
          /packedarraytype eq
        or not
        { 1 array  astore }
      if
        dup type  /packedarraytype  eq  not
        { aload length packedarray }
      if
    } bind
    /realtype {
      cvr
    } bind
    /savetype { } bind
    /stringtype {
      dup type
      <<
        /stringtype { } bind
        /nametype { dup length string  cvs } bind
        /booleantype { 10 string  cvs } bind
        /realtype { 31 string  cvs } bind
        /integertype { 31 string  cvs } bind
        /default { 255 string  cvs } bind
      >>
      /procs /ProcSet findresource /switch get exec
    } bind
    /scripttype { % itg custom type for script block
      cvx
    } bind
    /default {
      $error begin
        [ 3 copy pop ] /errorinfo exch def
        /errorname /typecheck def
        /command /define_args def
        /recordstacks false def
      end
      stop
    }
  >>
  /procs /ProcSet findresource /switch get exec
} bind

/scriptcheck % param_name param_value script_block --> param_name param_value (assert)
{
  dup xcheck not  { pop stop } if
  $error begin
    % [ 4 copy pop pop  /scriptcheck ] /errorinfo exch def
    /errorname /invalidparam def
    /command /define_args def
    /recordstacks false def
  end
  1 index  exch
  exec
} bind

/rangecheck % param_name param_value [ min max ] --> param_name param_value (assert)
{
  dup type /arraytype eq not  { pop stop } if
  dup length  2 eq not  { pop stop } if
  $error begin
    [ 4 copy pop  /rangecheck ] /errorinfo exch def
    /errorname /invalidparam def
    /command /define_args def
    /recordstacks false def
  end
  2 copy  0 get  ge not  { pop stop } if
  2 copy  1 get  le not  { pop stop } if
  pop
} bind

/lengthcheck % param_name param_value [ min_length max_length ] / length --> param_name param_value (assert)
{
  dup type /integertype eq { dup  2 array astore } if
  dup type /arraytype eq not  { pop stop } if
  dup length  2 eq not  { pop stop } if
  $error begin
    [ 4 copy pop  /lengthcheck ] /errorinfo exch def
    /errorname /invalidparam def
    /command /define_args def
    /recordstacks false def
  end
  { 1 index  length } stopped { pop stop } if
  exch
  2 copy  0 get  ge not  { pop pop stop } if
  2 copy  1 get  le not  { pop pop stop } if
  pop pop
} bind

/enumcheck % param_name param_value [ enum_items ] --> param_name param_value (assert)
{
  dup type /arraytype eq not  { pop stop } if
  $error begin
    [ 4 copy pop  /enumcheck ] /errorinfo exch def
    /errorname /invalidparam def
    /command /define_args def
    /recordstacks false def
  end
    1 index  exch  /arrays /aexists eexec
  not  { stop } if
} bind

>>

>> /ProcSet defineresource pop
%%EndResource:
%} ifelse

%%EndProlog
