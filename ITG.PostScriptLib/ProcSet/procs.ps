%!PS-Adobe-3.0
%%Creator: Sergey S. Betke <sergey.s.betke@yandex.ru>
%%Copyright: 2018 Sergey S. Betke <sergey.s.betke@yandex.ru>
%%+ See LICENSE at https://github.com/Metrolog/marks
%%DocumentData: Clean7Bit
%%DocumentNeededResources: ProcSet (arrays) 2.2 0
%%DocumentSuppliedResources: ProcSet (procs)
%%Version: 2.3 0
%%EndComments
%%BeginProlog

%%IncludeResource: ProcSet arrays 2.2 0

%(procs) /ProcSet resourcestatus { pop pop } {
%!PS-Adobe-3.0 Resource-ProcSet
%%BeginResource: ProcSet (procs)
/procs <<

/switch
{
  exch  2 copy  known
    { get exec }
    {
        exch
        dup /default known
        {
          exch pop
          /default get exec
        }
        {
          pop
          $error begin
            /errorinfo exch def
            /errorname /unexpectedswitchvalue def
            /command /switch def
            /recordstacks false def
          end
          stop
        }
      ifelse
    }
  ifelse
} bind

/define_args
{
  /arrays /ProcSet findresource /areverse get exec

  dup [ exch
      {
        dup type
        <<
          /nametype {} bind
          /dicttype {
              dup /arg known
              { /arg get }
              {
                $error begin
                  /errorinfo exch def
                  /errorname /unexpectedparamdefinition def
                  /command /define_args def
                  /recordstacks false def
                end
                cleartomark
                pop
                stop
              }
            ifelse
          } bind
          /default {
            $error begin
              /errorinfo exch def
              /errorname /unexpectedparamdefinition def
              /command /define_args def
              /recordstacks false def
            end
            cleartomark
            pop
            stop
          } bind
        >>
        /procs /ProcSet findresource /switch get exec
      }
    forall
  ]

  exch
  <<  exch
      {
        dup type
        <<
          /nametype { null } bind
          /dicttype { dup  /arg get  exch } bind
        >>
        /procs /ProcSet findresource /switch get exec
      }
    forall
  >>  begin

      1 index  type  /dicttype  eq
      { pop }
      {
        dup length dict begin
          { exch def } forall
          currentdict
        end
      }
    ifelse

      {
          currentdict  2 index  known
          { def }
          {
            $error begin
              2 array  astore  /errorinfo exch def
              /errorname /unknownparam def
              /command /define_args def
              /recordstacks false def
            end
            end
            stop
          }
        ifelse
      }
    forall

    currentdict

  end
  readonly
  1 dict begin
  /args exch def
} bind

/leave_local_scope
{
  end
} bind

>> /ProcSet defineresource pop
%%EndResource:
%} ifelse

%%EndProlog
